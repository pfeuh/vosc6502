#!/usr/bin/python
# -*- coding: utf-8 -*-

header = """# https://www.atarimax.com/jindroush.atari.org/aopc.html
# Implied       BRK           $00
# Accumulator   ASL A         $0A
# Immediate     ADC #$44      $69
# Zero Page     ADC $44       $65
# Zero Page,X   ADC $44,X     $75
# Zero Page,Y   LDX $44,Y     $B6
# Absolute      ADC $4400     $6D
# Absolute,X    ADC $4400,X   $7D
# Absolute,Y    ADC $4400,Y   $79
# Indirect      JMP ($5597)   $6C
# Indirect,X    ADC ($44,X)   $61
# Indirect,Y    ADC ($44),Y   $71
# Relative      BEQ           $10
"""

import sys
import os
import random

def write(text, fp=sys.stdout):
    fp.write(str(text))
    
def writeln(text, fp=sys.stdout):
    write(text, fp)
    write("\n", fp)

def get8BitsValueText():
    return "$%02X"%random.randint(0, 255)

def get16BitsValueText():
    return "$%04X"%random.randint(256, 65535)

def makeTable(items, table_name, nb_cols=8, width=5, quote=True, fp=sys.stdout):
    writeln("%s = ("%table_name, fp)
    for num, label in enumerate(items):
        if not (num % nb_cols):
            line = "    "

        if label != None:
            if quote:
                label = "'%s'"%label
            else:
                if type(label) == str:
                    label = "%s"%label.upper()
                else:
                    label = str(label)
        else:
            label = "None"
        while len(label) < width:
            label += " "
        line += "%s, "%label

        if (num % nb_cols) == nb_cols - 1:
            writeln(line, fp)
            line = ""
    if line != "":
            writeln(line, fp)
    writeln("    )\n", fp)

def generatePythonTables(table1, table2, fp=sys.stdout):
    writeln("#!/usr/bin/python\n# -*- coding: utf-8 -*-\n", fp)
    writeln("# This file is autogenerated... If you modify it,", fp)
    writeln("# it will be overwritten by the next update!\n", fp)
    writeln(header, fp)
    opcodes = []
    mnemos = []
    modes = []
    def_modes = []

    for num in range(len(table1)):
        mnemo = table1[num][1:-1].lower()
        mode = table2[num]

        if mnemo == "???":
            mode = None
            mnemo = None
        if mnemo != None:
            if not mnemo in opcodes:
                opcodes.append(mnemo)
        mnemos.append(mnemo)
        modes.append(mode)
        if not mode in def_modes:
            if mode != None:
                def_modes.append(mode)
                    
    makeTable(opcodes, "OPCODES", fp=fp, nb_cols=16)
    makeTable(mnemos, "OPCODE_VALUES", fp=fp, nb_cols=16)
    for mode in def_modes:
        writeln("%s = '%s'"%(mode.upper(), mode), fp)
    writeln("", fp)
    
    makeTable(modes, "MODES", nb_cols=4, width=11, quote=False, fp=fp)

    relatives = []
    for index, mode in enumerate(table2):
        if mode == 'Relative':
            relatives.append(table1[index][1:-1])
    makeTable(relatives, "RELATIVE_OPCODES", fp=fp)
    
    implieds = []
    for index, mode in enumerate(table2):
        opcode = table1[index][1:-1]
        if mode == 'Implied' and opcode != "???":
            implieds.append(opcode)
    makeTable(implieds, "IMPLIED_OPCODES", fp=fp)
    
    code_sizes = []
    for index, mode in enumerate(table2):
        if table1[index] == '"???"':
            code_sizes.append(None)

        elif mode in ("Implied", "Accumulator"):
            code_sizes.append(1)
            
        elif mode in ("IndirectX", "ZeroPage", "Immediate", "Relative", "IndirectY", "IndirectX", "ZeroPageX", "ZeroPageY"):
            code_sizes.append(2)
            
        elif mode in ("Absolute", "AbsoluteY", "AbsoluteX", "Indirect"):
            code_sizes.append(3)
            
        else:
            raise Exception("unknown mode %s"%mode)
    
    assert len(code_sizes) == 256
    makeTable(code_sizes, "CODE_SIZES", fp=fp, nb_cols=16, quote=False, width=4)
    
    opcodes.sort()
    for opcode in opcodes:
        temp_list = []
        for x in range(256):
            mnemo = table1[x][1:-1]
            mode = table2[x].upper()
            if mnemo == opcode:
                if not mode in temp_list:
                    temp_list.append(mode)
        makeTable(temp_list, "%s_MODES"%opcode.upper(), fp=fp, nb_cols=16, quote=False, width=4)    

    for opcode in opcodes:
        temp_list = []
        for x in range(256):
            mnemo = table1[x][1:-1]
            mode = table2[x].upper()
            if mnemo == opcode:
                if not mode in temp_list:
                    temp_list.append(mode)
        makeTable(temp_list, "%s_MODES"%opcode.upper(), fp=fp, nb_cols=16, quote=False, width=4)    


    fp.write("MODES_BY_MNEMONIC = {\n")
    for opcode in opcodes:
        fp.write("    '%s':%s_MODES,\n"%(opcode, opcode.upper()))
    fp.write("    }\n")
    
    with open("opcodes_map.txt", "wb") as fp:
        for opcode in range(256):
            mode = table2[opcode]
            mnemo = table1[opcode][1:-1]
            if mnemo == '???':
                mnemo = '---'
                mode = '---'
            writeln("%02x %s %s"%(opcode, mnemo, mode), fp=fp)

def createTestProgram(opcodes, modes, fp=sys.stdout):
    writeln("\n    ; -------------------------------------- ;", fp)
    writeln("    ;  this program is supposed to use all   ;", fp)
    writeln("    ;       the official 6502 opcodes        ;", fp)
    writeln("    ; -------------------------------------- ;\n", fp)
    writeln("    ;* = $200 ; (un)comment if neccessary", fp)
    writeln("    ;_main: ; (un)comment if neccessary", fp)
    writeln("    ;.export _main ; (un)comment if neccessary\n", fp)
    nb_valid = 0
    for index, opcode in enumerate(opcodes):
        if not (index % 16):
            label = "LABEL_%02d"%(index / 16 + 1)
            writeln("%s:"%label, fp)
        
        opcode = opcode[1:-1].upper()
        mode = modes[index]
        if opcode == "???":
            writeln("                 ; opcode $%02x (illegal)"%(index), fp)
        else:
            nb_valid += 1
            
            if mode == 'inherent':
                text = opcode
            elif mode == 'immediate':
                text = opcode + ' #' + get8BitsValueText()
            elif mode == 'indirect':
                text = opcode + '(' + get16BitsValueText() + ')'
            elif mode == 'accumulator':
                text = opcode + ' A'
            elif mode == 'absolute':
                text = opcode + ' ' + get16BitsValueText()
            elif mode == 'absolx':
                text = opcode + ' ' + get16BitsValueText() + ',X'
            elif mode == 'absoly':
                text = opcode + ' ' + get16BitsValueText() + ',Y'
            elif mode == 'indzerox':
                text = opcode + ' ' + '(' + get8BitsValueText() + ',X)'
            elif mode == 'indzeroy':
                text = opcode + ' ' + '(' + get8BitsValueText() + '),Y'
            elif mode == 'relative':
                text = opcode + ' ' + label
            elif mode == 'zeropage':
                text = opcode + ' ' + get8BitsValueText()
            elif mode == 'zeropagex':
                text = opcode + ' ' + get8BitsValueText() + ',X'
            elif mode == 'zeropagey':
                text = opcode + ' ' + get8BitsValueText() + ',Y'

            else:
                text = opcode + ' ???'

            writeln("    %-12s ; opcode $%02x"%(text, index), fp)

    return nb_valid

def removeComment(text):
    otext = ""
    for car in text:
        if car != "/":
            otext += car
        else:
            return otext.strip()
    
def text2table(lines, tname):
    # don't mess with the format of this file!
    state_wait_tname   = 1
    state_wait_opening = 2
    state_running      = 3
    state = state_wait_tname
    text = ""
    for line in lines:
        if state == state_wait_tname:
            if "%s[]"%tname in line:
                state = state_wait_opening
        elif state == state_wait_opening:
            if "{" in line:
                state = state_running
        elif state == state_running:
            if "}" in line:
                break
            else:
                text += removeComment(line)
    return [word.strip() for word in text.split(',')]

def tableElementReplace(table, old, new):
    for index, item in enumerate(table):
        if item == old:
            table[index] = new

def getAsmLine(value, opcode, mode):
    line = "%s "%opcode.upper()
    
    if mode == "Implied":
        return line
    elif mode == "Accumulator":
        return line + "A"
    elif mode == "Immediate":
        return line + "#$44"
    elif mode == "ZeroPage":
        return line + "$44"
    elif mode == "ZeroPageX":
        return line + "$44,X"
    elif mode == "ZeroPageY":
        return line + "$44,Y"
    elif mode == "Absolute":
        return line + "$4400"
    elif mode == "AbsoluteX":
        return line + "$4400,X"
    elif mode == "AbsoluteY":
        return line + "$4400,Y"
    elif mode == "Indirect":
        return line + "($4400)"
    elif mode == "IndirectX":
        return line + "($44,X)"
    elif mode == "IndirectY":
        return line + "($44),Y"
    elif mode == "Relative":
        return line + "$1234"
    else:
        raise Exception("%02x %s %s : WTF???"%(value, opcode, mode))
    return line

def generateOpcodesChart(opcodes, modes, fp):
    line = ";"
    for x in range(16):
        line += "x%X;"%x
    writeln(line, fp)

    for x in range(256):
        if not x % 16:
            line2 = "%Xx;"%(x/16)
            line1 = ";"
            
        mnemo = opcodes[x][1:-1]
        mode = modes[x]
        
        if mnemo != "???":
            line1 += "%s;"%modes[x]
            line2 += "%s;"%getAsmLine(x, mnemo, mode)
        else:
            line1 += ";"
            line2 += ";"
        
        if (x % 16) == 15:
            writeln(line1, fp)
            writeln(line2, fp)
            writeln(";", fp)

def generateModesChart(opcodes, modes, fp):
    chart = {}
    for opcode in opcodes:
            mnemonic = opcode[1:-1]
            if mnemonic != "???":
                if mnemonic in chart.keys():
                    pass
                else:
                    chart[mnemonic] = []

    for index, opcode in enumerate(opcodes):
            mnemonic = opcode[1:-1]
            if mnemonic != "???":
                if mnemonic in chart.keys():
                    chart[mnemonic].append(modes[index])
                    
                    
    modes_list = []
    for x in range(256):
        if not modes[x] in modes_list:
            modes_list.append(modes[x])

    keys = chart.keys()
    keys.sort()
    for key in keys:
        fp.write("%s;"%key.upper())
        line = chart[key]
        for mode in modes_list:
            if mode in line:
                fp.write("%s;"%mode)
            else:
                fp.write(";")
        fp.write("\n")

if __name__ == "__main__":

    # this is my reference document
    with open("../src/desass6502tables.h") as fp:
        lines = fp.readlines()

    # job for generating test_opcodes.asm
    opcodes = text2table(lines, "mnemo")
    modes = text2table(lines, "*hook")
    assert len(opcodes) == 256
    assert len(modes) == 256
    with open("../sample/test_opcodes/test_opcodes.asm", "w") as fp:
        nb_valid = createTestProgram(opcodes, modes, fp)
    writeln("%d 6502-opcodes created"%nb_valid)

    # job for generating tables for python tools
    opcodes = text2table(lines, "mnemo")
    modes = text2table(lines, "*hook")
    tableElementReplace(modes, "inherent", "Implied")
    tableElementReplace(modes, "accumulator", "Accumulator")
    tableElementReplace(modes, "immediate", "Immediate")
    tableElementReplace(modes, "zeropage", "ZeroPage")
    tableElementReplace(modes, "zeropagex", "ZeroPageX")
    tableElementReplace(modes, "zeropagey", "ZeroPageY")
    tableElementReplace(modes, "absolute", "Absolute")
    tableElementReplace(modes, "absolx", "AbsoluteX")
    tableElementReplace(modes, "absoly", "AbsoluteY")
    tableElementReplace(modes, "indirect", "Indirect")
    tableElementReplace(modes, "indzerox", "IndirectX")
    tableElementReplace(modes, "indzeroy", "IndirectY")
    tableElementReplace(modes, "relative", "Relative")
    with open("../../../../python/atasmPrecompiler/tables6502.py", "w") as fp:
        generatePythonTables(opcodes, modes, fp)
    with open("../../../../python/atasmPrecompiler/utest/chart6502.csv", "w") as fp:
        generateOpcodesChart(opcodes, modes, fp)
    with open("../../../../python/atasmPrecompiler/utest/modes6502.csv", "w") as fp:
        generateModesChart(opcodes, modes, fp)
